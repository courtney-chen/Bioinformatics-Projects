# install.packages("seqinr")
library(plyr)
library(seqinr)
library(ggplot2)
library(gridExtra)

plotData <- function(seq,nucleotides,title){
  # seq generated
  # nt in the seq
  # plot title
  freqNucleotide <- count(seq,1,alphabet=nucleotides,freq=TRUE)
  # count function to count the frequency of each/single nt in the seq 
  freqDiNucleotide <- count(seq,2,alphabet=nucleotides,freq=TRUE)
  # count the frequency of 2 nt in the seq
  freqTriNucleotide <- count(seq,3,alphabet=nucleotides,freq=TRUE)
  # count the freq of 3 nts in the seq
  
  df <- as.data.frame(freqNucleotide)
  # create a data frame called df for the frequency of 1/each nt in the seq
  colnames(df) <- c("Base", "Base_Proportion")
  # give column names, row, column
  p1 <- ggplot(df, aes(x = Base, y = Base_Proportion, fill=Base )) +
    geom_bar(stat = "identity")
  p1 <- p1 + theme(legend.position="none") +
    ggtitle("Compositional bias of each nucleotide")
  
  # below is the repeat, but for di and tri nt
  df <- as.data.frame(freqDiNucleotide)
  colnames(df) <- c("Base", "Base_Proportion")
  p2 <- ggplot(df, aes(x = Base, y = Base_Proportion, fill=Base )) +
    geom_bar(stat = "identity")
  p2 <- p2 + theme(legend.position="none") +
    ggtitle("Compositional bias of each dinucleotide")
  
  df <- as.data.frame(freqTriNucleotide)
  colnames(df) <- c("Base", "Base_Proportion")
  p3 <- ggplot(df, aes(x = Base, y = Base_Proportion, fill=Base )) +
    geom_bar(stat = "identity")
  p3 <- p3 + theme(legend.position="none") +
    ggtitle("Compositional bias of each trinucleotide") +
    theme(axis.text.x  = element_text(angle=90, vjust=0.5, size=8) )
  
  # arrange all 3 plots in same plot
  grid.arrange(p1, p2, p3, nrow=3, top=title)
}

# Create a function to generate the sequence
generateFirstOrderSeq <- function(lengthSeq,nucleotides,initialProb,firstOrderMatrix){
  #(length of the sequence,nt,initial probability distribution,
  # &matrix that stores the probability distribution of a first order Markov Chain)
  
  # Create a vector for storing the new sequence
  outputSeq <- character()
  firstnucleotide <- sample(nucleotides, 1, rep=TRUE, prob=initialProb)
  # Store the nucleotide for the first position of the sequence
  outputSeq[1] <- firstnucleotide
  
  # Let the computer decide:
  for(i in 2:lengthSeq){
    prevNuc <- outputSeq[i-1]
    currentProb <- firstOrderMatrix[prevNuc,]
    #cat("\n", prevNuc, " " , currentProb, sep=" ")
    outputSeq[i] <- sample(nucleotides,1,prob=currentProb)
  }
  return(outputSeq)
}
# Function to generate a DNA sequence, given a HMM and the length of the sequence to be generated.
generateFirstOrderhmmseq <- function(lengthSeq, nucleotides, initialProb, states, 
                                     transitionmatrix, emissionmatrix){
  #    states -> states for the HMM
  #    transitionmatrix -> matrix that stores the probability distribution of transitions
  #    emissionmatrix -> matrix that stores the probability distribution of emissions
  
  outputSeq <- character()
  # Create a vector for storing the new sequence
  mystates  <- character()
  # Create a vector for storing the state that each position in the new sequence
  # was generated by
  # Choose the state for the first position in the sequence:
  firststate <- sample(states, 1, rep=TRUE, prob=initialProb)
  # Get the probabilities of the current nucleotide, given that we are in the state "firststate":
  probabilities <- emissionmatrix[firststate,]
  # Choose the nucleotide for the first position in the sequence:
  firstnucleotide <- sample(nucleotides, 1, rep=TRUE, prob=probabilities)
  outputSeq[1]<- firstnucleotide
  # Store the nucleotide for the first position of the sequence
  mystates[1] <- firststate
  # Store the state that the first position in the sequence was generated by
  
  for (i in 2:lengthSeq){
    prevstate <- mystates[i-1]
    # Get the state that the previous nucleotide in the sequence was generated by
    stateprobs <- transitionmatrix[prevstate,]
    # Choose the state for the ith position in the sequence:
    state <- sample(states, 1, rep=TRUE, prob=stateprobs)
    # Get the probabilities of the current nucleotide, given that we are in the state "state":
    probabilities <- emissionmatrix[state,]
    # Choose the nucleotide for the ith position in the sequence:
    nucleotide <- sample(nucleotides, 1, rep=TRUE, prob=probabilities)
    outputSeq[i] <- nucleotide
    # Store the nucleotide for the current position of the sequence
    mystates[i]  <- state
    # Store the state that the current position in the sequence was generated by
  }
  
  for (i in 1:lengthSeq){
    nucleotide <- outputSeq[i]
    state <- mystates[i]
    print(paste("Position", i, ", State", state, ", Nucleotide = ", nucleotide))
  }
  return(outputSeq)
}

viterbi <- function(sequence, transitionmatrix, emissionmatrix){
  
  #    sequence<- character vector for the sequence
  #    transitionmatrix <- matrix that stores the probability distribution of transitions
  #    emissionmatrix <- matrix that stores the probability distribution of emissions
  
  # This carries out the Viterbi algorithm.
  # Get the names of the states in the HMM:
  states <- rownames(emissionmatrix)
  
  # Make the Viterbi matrix v:
  v <- makeViterbimat(sequence, transitionmatrix, emissionmatrix)
  
  # Go through each of the rows of the matrix v (where each row represents
  # a position in the DNA sequence), and find out which column has the
  # maximum value for that row (where each column represents one state of
  # the HMM):
  mostprobablestatepath <- apply(v, 1, function(x) which.max(x))
  
  # Print out the most probable state path:
  prevnucleotide <- sequence[1]
  prevmostprobablestate <- mostprobablestatepath[1]
  prevmostprobablestatename <- states[prevmostprobablestate]
  startpos <- 1
  
  for (i in 2:length(sequence)){
    nucleotide<- sequence[i]
    mostprobablestate<- mostprobablestatepath[i]
    mostprobablestatename <- states[mostprobablestate]
    if (mostprobablestatename != prevmostprobablestatename){
      print(paste("Positions",startpos,"-",(i-1),
                  "Most probable state = ", prevmostprobablestatename))
      startpos <- i
    }
    prevnucleotide <- nucleotide
    prevmostprobablestatename <- mostprobablestatename
  }
  print(paste("Positions",startpos,"-",i,
              "Most probable state = ", prevmostprobablestatename))
}

makeViterbimat <- function(sequence, transitionmatrix, emissionmatrix) {
  
  #    sequence <- character vector for the sequence
  #    transitionmatrix <-matrix that stores the probability distribution of transitions
  #    emissionmatrix <- matrix that stores the probability distribution of emissions  
  
  # This makes the matrix v using the Viterbi algorithm.
  # Change the sequence to uppercase
  sequence <- toupper(sequence)
  # how many states are in the HMM
  numstates <- dim(transitionmatrix)[1]
  # Make a matrix with as many rows as positions in the sequence, and as many
  v <- matrix(NA, nrow = length(sequence), ncol = dim(transitionmatrix)[1])
  # Set the values in the first row of matrix v 
  # (representing the first position of the sequence) to 0
  v[1, ] <- 0
  # Set the value in the first row of matrix v, first column to 1
  v[1,1] <- 1
  # Fill in the matrix v:
  for (i in 2:length(sequence)) { # For each position in the DNA sequence:
    for (l in 1:numstates) { # For each of the states of in the HMM:
      # Find the probabilility, if we are in state l, 
      # of choosing the nucleotide at position in the sequence
      statelprobnucleotidei <- emissionmatrix[l,sequence[i]]
      v[i,l] <-  statelprobnucleotidei * max(v[(i-1),] * transitionmatrix[,l])
    }
  }
  return(v)
}

#End of Functions
pdf("markov_plots.pdf")


# Define the DNA alphabet that will be used to put names to the objects
nucleotides <- c("A","C","G","T")
# Create the vector that represents the probability distribution of the model
zeroOrderProbablities <- c(0.2,0.3,0.3,0.2)
# Put the name of reference of each base 
names(zeroOrderProbablities) <- nucleotides
# Create a sequence of 1000 bases using this model.
zeroOrderSeq <- sample(nucleotides,1000,rep=T,prob=zeroOrderProbablities)

plotData(zeroOrderSeq, nucleotides, "Multinomial Model of DNA Evoloution")

# Add the probability distribution per base:
afterAprobs <- c(0.2,0.3,0.3,0.2)  
# Set the values of the probabilities, where the previous nucleotide was "A"
afterCprobs <- c(0.1,0.41,0.39,0.1)  
# Set the values of the probabilities, where the previous nucleotide was "C"
afterGprobs <- c(0.25,0.25,0.25,0.25)
# Set the values of the probabilities, where the previous nucleotide was "G"
afterTprobs <- c(0.5,0.17,0.17,0.17)
# Set the values of the probabilities, where the previous nucleotide was "T"

# Create the matrix that will store the probability distribution given 
# a certain nucleotide:
mytransitionmatrix <- matrix(c(afterAprobs, afterCprobs, afterGprobs, afterTprobs), 4, 4, byrow = TRUE) # Create a 4 x 4 matrix

# Put names to the 2 dimensions of the matrix 
colnames(mytransitionmatrix) <- nucleotides
rownames(mytransitionmatrix) <- nucleotides

# In order to continue, we need an initial probability distribution to know
# which base is the most probable to start up the sequence.
inProb <- c(0.4,0.1,0.1,0.4)
names(inProb) <- nucleotides
# So, the sequence will have a 40% to start with an A or a T and 10% with C or G

# Use the generateFirstOrderSeq function to generate a sequence of 1000 bases long
firstOrderSeq <- generateFirstOrderSeq(1000,nucleotides,inProb,mytransitionmatrix)
# plot the data
plotData(firstOrderSeq, nucleotides, "Markov Chain of first order")


states <- c("AT-rich", "GC-rich") # Define the names of the states
ATrichprobs <- c(0.7, 0.3)
# Set the probabilities of switching states, where the previous state was "AT-rich"
GCrichprobs <- c(0.1, 0.9)
# Set the probabilities of switching states, where the previous state was "GC-rich"
theTransitionMatrix <- matrix(c(ATrichprobs, GCrichprobs), 2, 2, byrow = TRUE) 
# Create a 2 x 2 matrix
rownames(theTransitionMatrix) <- states
colnames(theTransitionMatrix) <- states

ATrichstateprobs<- c(0.39, 0.1, 0.1, 0.41) 
# Set the values of the probabilities, for the AT-rich state
GCrichstateprobs <- c(0.1, 0.41, 0.39, 0.1) 
# Set the values of the probabilities, for the GC-rich state
theEmissionMatrix<- matrix(c(ATrichstateprobs, GCrichstateprobs), 2, 4, byrow = TRUE) 
# Create a 2 x 4 matrix
rownames(theEmissionMatrix) <- states
colnames(theEmissionMatrix) <- nucleotides

# We can use the generateFirstOrderhmmseq() function to generate a sequence using a particular HMM. 
# transition matrix thetransitionmatrix, the emission matrix theemissionmatrix, 
# and uniform starting probabilities (ie. ΠAT-rich = 0.5, ΠGC-rich = 0.5), we type:
initialProb <- c(0.5, 0.5)
hmmfirstOrderSeq = generateFirstOrderhmmseq(10000, nucleotides, initialProb, states, theTransitionMatrix, theEmissionMatrix)
plotData(hmmfirstOrderSeq, nucleotides,  "Hidden Markov Model of first order")
# Given a HMM, and a particular DNA sequence, you can use the Viterbi function 
# to find the state of that HMM that was most likely to have generated the nucleotide at each 
# position in the DNA sequence:
myseq <- c("A", "A", "G", "C", "G", "T", "G", "G", "G", "G", "C", "C", "C", "C",
           "G", "G", "C", "G", "A", "C", "A", "T", "G", "G", "G", "G", "T", "G",
           "T", "C")
viterbi(myseq, theTransitionMatrix, theEmissionMatrix)

#install.packages(markovchain)

dev.off()